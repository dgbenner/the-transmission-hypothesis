<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE TRANSMISSION HYPOTHESIS</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000000;
            color: #00FF00;
            font-family: 'IBM Plex Mono', monospace;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* CRT scanline effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(0, 255, 0, 0.02) 50%,
                rgba(0, 0, 0, 0.02) 50%
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 1000;
        }

        /* CRT flicker effect */
        @keyframes flicker {
            0% { opacity: 0.97; }
            50% { opacity: 1; }
            100% { opacity: 0.97; }
        }

        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 255, 0, 0.03);
            pointer-events: none;
            z-index: 999;
            animation: flicker 0.15s infinite;
        }

        .header {
            text-align: center;
            padding: 1.5rem 1rem 1rem;
            border-bottom: 2px solid #00FF00;
            position: relative;
            z-index: 10;
            flex-shrink: 0;
        }

        .status {
            font-size: 0.875rem;
            letter-spacing: 0.2em;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: center;
            gap: 2rem;
        }

        .now-playing {
            font-size: 1.1rem;
            letter-spacing: 0.1em;
            margin-bottom: 0.75rem;
            font-weight: 600;
        }

        .meta {
            font-size: 0.675rem;
            letter-spacing: 0.15em;
            display: flex;
            justify-content: center;
            gap: 2rem;
        }

        .video-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            position: relative;
            z-index: 10;
            min-height: 0;
            overflow: hidden;
        }

        video {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain;
            border: none;
            filter: contrast(1.1) brightness(0.95);
        }

        /* Remove ALL video controls */
        video::-webkit-media-controls {
            display: none !important;
            -webkit-appearance: none !important;
        }

        video::-webkit-media-controls-enclosure {
            display: none !important;
        }

        video::-webkit-media-controls-panel {
            display: none !important;
        }

        video::-webkit-media-controls-play-button {
            display: none !important;
        }

        video::-webkit-media-controls-timeline {
            display: none !important;
        }

        video::-webkit-media-controls-current-time-display {
            display: none !important;
        }

        video::-webkit-media-controls-time-remaining-display {
            display: none !important;
        }

        video::-webkit-media-controls-mute-button {
            display: none !important;
        }

        video::-webkit-media-controls-volume-slider {
            display: none !important;
        }

        video::-webkit-media-controls-fullscreen-button {
            display: none !important;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .status {
                font-size: 0.75rem;
            }

            .now-playing {
                font-size: 0.95rem;
            }

            .meta {
                font-size: 0.75rem;
                gap: 1rem;
            }

            .header {
                padding: 1rem 0.5rem 0.75rem;
            }
        }

        @media (max-width: 480px) {
            .status {
                font-size: 0.625rem;
            }

            .now-playing {
                font-size: 0.8rem;
            }

            .meta {
                font-size: 0.625rem;
                flex-direction: column;
                gap: 0.25rem;
            }
        }

        /* Text glow effect */
        /* Slow pulsing glow for the status indicator */
        @keyframes slow-glow {
            0% {
                text-shadow: 0 0 6px rgba(0,255,0,0.5), 0 0 20px rgba(0,255,0,0.05);
                opacity: 0.9;
                filter: brightness(0.9);
            }
            50% {
                text-shadow: 0 0 18px rgba(0,255,0,1), 0 0 40px rgba(0,255,0,0.15);
                opacity: 1;
                filter: brightness(1.05);
            }
            100% {
                text-shadow: 0 0 6px rgba(0,255,0,0.5), 0 0 20px rgba(0,255,0,0.05);
                opacity: 0.9;
                filter: brightness(0.9);
            }
        }

        .status {
            animation: slow-glow 12s ease-in-out infinite;
        }

        .now-playing,
        .meta {
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
        }

        /* Connection overlay */
        #connectionOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000000;
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: opacity 0.8s ease-out;
        }

        #connectionOverlay.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        #connectionMessage {
            font-size: 1.5rem;
            letter-spacing: 0.3em;
            text-align: center;
            text-shadow: 0 0 20px rgba(0, 255, 0, 1);
            animation: slow-glow 4s ease-in-out infinite;
        }

        @media (max-width: 768px) {
            #connectionMessage {
                font-size: 1.1rem;
                letter-spacing: 0.2em;
            }
        }

        @media (max-width: 480px) {
            #connectionMessage {
                font-size: 0.9rem;
                letter-spacing: 0.15em;
            }
        }
    </style>
</head>
<body>
    <!-- Connection overlay -->
    <div id="connectionOverlay">
        <div id="connectionMessage">CLICK TO RECEIVE SIGNAL</div>
    </div>

    <div class="header">
        <div class="status">
            <span>SIGNAL: ACTIVE</span>
            <span>FREQUENCY: <span id="frequency">540.7 MHz</span></span>
        </div>
        <div class="now-playing">TX: <span id="transmission">THETA-7 DND-87-D</span></div>
        <div class="meta">
            <span id="timer">--</span>
        </div>
    </div>

    <div class="video-container">
        <video id="videoPlayer" preload="auto" autoplay playsinline crossorigin="anonymous">
            Your terminal does not support video transmission.
        </video>
    </div>

    <script>
        // Generate obscured code from filename with persistent storage
        function generateCode(filename) {
            // Check if we already have a stored code for this filename
            const storedCodes = JSON.parse(localStorage.getItem('transmissionCodes') || '{}');

            if (storedCodes[filename]) {
                return storedCodes[filename];
            }

            // Remove extension
            const name = filename.replace(/\.(mp3|mp4|m4v)$/i, '');

            // Split by spaces, hyphens, or underscores
            const words = name.split(/[\s\-_]+/).filter(w => w.length > 0);

            // Create acronym from first letters
            const acronym = words.map(w => w.charAt(0).toUpperCase()).join('');

            // Generate consistent random numbers based on filename
            // Use simple hash function for consistency
            let hash = 0;
            for (let i = 0; i < filename.length; i++) {
                hash = ((hash << 5) - hash) + filename.charCodeAt(i);
                hash = hash & hash; // Convert to 32-bit integer
            }

            // Generate consistent 2-digit number (10-99)
            const num1 = (Math.abs(hash % 90) + 10).toString();

            // Generate consistent 2 alphanumeric characters
            const chars = 'ABCDEFGHIJKLMNPQRSTUVWXYZ23456789'; // Removed O, 0, 1, I for clarity
            const char1 = chars[Math.abs(hash % chars.length)];
            const char2 = chars[Math.abs((hash >> 8) % chars.length)];

            const code = `${acronym}-${num1}-${char1}${char2}`;

            // Store the generated code
            storedCodes[filename] = code;
            localStorage.setItem('transmissionCodes', JSON.stringify(storedCodes));

            return code;
        }

        // Protocol names for each transmission
        const protocols = [
            'THETA-7', 'SIGMA-3', 'ALPHA-9', 'DELTA-4', 'OMEGA-2', 'ZETA-6',
            'KAPPA-1', 'BETA-5', 'GAMMA-8', 'EPSILON-2', 'PHI-4', 'RHO-6',
            'PSI-9', 'LAMBDA-5', 'MU-8', 'NU-3', 'XI-7', 'OMICRON-4', 'PI-2',
            'TAU-6', 'UPSILON-9', 'CHI-1', 'ETA-5', 'IOTA-3'
        ];

        // Video files in /media/video/ - UPDATE THIS LIST when adding new files
        const videoFiles = [
            'anti drug public service message .mp4',
            'Broadcast and The Focus Group Investigate Wit.mp4',
            'cafe flesh pruto foridideio 1982 United Stat.mp4',
            'End of Broadcast Test Pattern  ABRN 6 Lis.mp4',
            'german teletext adult mix.mp4',
            'join us.mp4',
            'K.E.A on X LEnfer Henri-Georges Clouzot Seconds John Frankenheim.mp4',
            'Kenny Omega vs. Haruka 2011 Japan Stardom.mp4',
            'les conflit de etoile.mp4',
            'Lets Visit The World Of The Future 1973 Unite.mp4',
            'life is flashing before your eyes.mp4',
            'Liquid Sky 1982 United States Slava Tsukerman.mp4',
            'monkey doddle les elton.mp4',
            'nightbreed.mp4',
            'nike max jean luc godard.mp4',
            'oz Film Manufacturing Company Logo 1914 Unite.mp4',
            'Professor Balthazar - Starlight Serenaders 19.mp4',
            'psychotronica on X End of Day Sign-Off 1990 American Exxxtasy so.mp4',
            'psychotronica on X Shoplifters The Criminal Hordes 1983 United S.mp4',
            'skin tight.mp4',
            'slam dance.mp4',
            'sound check on mirror .mp4',
            'station duspute 1979.mp4',
            'test pattern the police.mp4',
            'the day after.m4v',
            'The Death of Muffinhead.mp4',
            'The Door with Dr. Jack Kevorkian.mp4',
            'the vampira show los anglesl.mp4',
            'the wizard of gore.mp4',
            'this is a test.mp4',
            'throbbing gristle discipline kazar pavillion.mp4'
        ];

        // Shuffle array function (Fisher-Yates shuffle)
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Load external links and combine with local files
        let transmissions = [];

        fetch('media/links.json')
            .then(response => response.json())
            .then(externalLinks => {
                console.log('Loaded external links:', externalLinks.length);

                // Generate transmissions from local video files
                const localTransmissions = videoFiles.map((filename, index) => {
                    // Create title from filename
                    const title = filename
                        .replace(/\.(mp4|m4v)$/i, '')
                        .split(/[\s\-_]+/)
                        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                        .join(' ');

                    const code = generateCode(filename);

                    return {
                        title: title,
                        url: `media/video/${filename}`,
                        protocol: protocols[index % protocols.length],
                        code: code,
                        source: 'local'
                    };
                });

                // Generate transmissions from external links
                const externalTransmissions = externalLinks.map((link, index) => {
                    const code = generateCode(link.title);

                    return {
                        title: link.title,
                        url: link.url,
                        protocol: protocols[(videoFiles.length + index) % protocols.length],
                        code: code,
                        source: 'external'
                    };
                });

                // Combine and shuffle all transmissions
                const allTransmissions = [...localTransmissions, ...externalTransmissions];
                transmissions = shuffleArray(allTransmissions);

                console.log('Total transmissions:', transmissions.length);
                console.log(`Local: ${localTransmissions.length}, External: ${externalTransmissions.length}`);
                console.log('Transmissions (randomized):', transmissions);

                // Initialize first transmission
                loadTransmission(currentIndex);
            })
            .catch(error => {
                console.error('Error loading external links, using local only:', error);

                // Fallback to local only if links.json fails to load
                const shuffledVideoFiles = shuffleArray(videoFiles);
                transmissions = shuffledVideoFiles.map((filename, index) => {
                    const title = filename
                        .replace(/\.(mp4|m4v)$/i, '')
                        .split(/[\s\-_]+/)
                        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                        .join(' ');

                    const code = generateCode(filename);

                    return {
                        title: title,
                        url: `media/video/${filename}`,
                        protocol: protocols[index % protocols.length],
                        code: code,
                        source: 'local'
                    };
                });

                console.log('Total transmissions (local only):', transmissions.length);

                // Initialize first transmission
                loadTransmission(currentIndex);
            });

        let currentIndex = 0;
        const video = document.getElementById('videoPlayer');
        const transmissionElement = document.getElementById('transmission');
        const timerElement = document.getElementById('timer');
        const frequencyElement = document.getElementById('frequency');
        const connectionOverlay = document.getElementById('connectionOverlay');
        const connectionMessage = document.getElementById('connectionMessage');

        // Handle connection overlay
        let connectionEstablished = false;

        connectionOverlay.addEventListener('click', () => {
            if (!connectionEstablished) {
                connectionEstablished = true;

                // Change message to "SIGNAL RECEIVED"
                connectionMessage.textContent = 'SIGNAL RECEIVED';

                // After 1.5 seconds, fade out overlay and start video
                setTimeout(() => {
                    connectionOverlay.classList.add('fade-out');

                    // Start video playback
                    video.play().catch(err => {
                        console.error('Play failed after connection:', err);
                    });

                    // Remove overlay from DOM after fade completes
                    setTimeout(() => {
                        connectionOverlay.remove();
                    }, 800); // Match the CSS transition duration
                }, 1500);
            }
        });

        // Frequency drift system
        const BASE_FREQUENCY = 540.7;
        let currentFrequency = BASE_FREQUENCY;
        let targetFrequency = BASE_FREQUENCY;
        let driftState = 'stable'; // 'stable', 'small-drift', 'spike'
        let driftEndTime = 0;

        function updateFrequency() {
            const now = Date.now();

            // Check if current drift/spike has ended
            if (driftState !== 'stable' && now >= driftEndTime) {
                // Return to base frequency
                driftState = 'stable';
                targetFrequency = BASE_FREQUENCY;
            }

            // When stable, randomly trigger drifts or spikes
            if (driftState === 'stable') {
                const rand = Math.random();

                // 2-3 large spikes per minute = ~3-4% chance per second
                if (rand < 0.035) {
                    driftState = 'spike';
                    // Randomly choose drop or spike
                    targetFrequency = Math.random() < 0.5 ? 538.2 : 541.9;
                    // Duration: 0.5-1.5 seconds
                    driftEndTime = now + (500 + Math.random() * 1000);
                }
                // 4-6 small drifts per minute = ~8-10% chance per second
                else if (rand < 0.10) {
                    driftState = 'small-drift';
                    // Drift between 540.5 - 540.9
                    targetFrequency = 540.5 + Math.random() * 0.4;
                    // Duration: 4-10 seconds
                    driftEndTime = now + (4000 + Math.random() * 6000);
                }
            }

            // Smoothly interpolate current frequency toward target
            const drift = targetFrequency - currentFrequency;
            if (Math.abs(drift) > 0.01) {
                // Spikes are faster, drifts are slower
                const speed = driftState === 'spike' ? 0.3 : 0.05;
                currentFrequency += drift * speed;
            } else {
                currentFrequency = targetFrequency;
            }

            // Update display
            frequencyElement.textContent = `${currentFrequency.toFixed(1)} MHz`;
        }

        // Update frequency every 100ms for smooth animation
        setInterval(updateFrequency, 100);

        // Load transmission
        function loadTransmission(index) {
            const transmission = transmissions[index];
            console.log(`Loading transmission ${index + 1}/${transmissions.length}:`, transmission);

            // Clear existing source
            video.pause();
            video.removeAttribute('src');
            while (video.firstChild) {
                video.removeChild(video.firstChild);
            }

            // Add new source
            const source = document.createElement('source');
            source.src = transmission.url;

            // Detect file type
            if (transmission.url.endsWith('.mp3')) {
                source.type = 'audio/mpeg';
            } else if (transmission.url.endsWith('.mp4')) {
                source.type = 'video/mp4';
            } else if (transmission.url.endsWith('.m4v')) {
                source.type = 'video/mp4';
            }

            video.appendChild(source);

            // Update UI - combine protocol and code
            transmissionElement.textContent = `${transmission.protocol} ${transmission.code}`;

            console.log(`Display updated: ${transmission.protocol} ${transmission.code}`);

            // Load video
            video.load();

            // Only autoplay if connection has been established
            if (connectionEstablished) {
                video.play().catch(err => {
                    console.error('Play failed:', err);
                });
            }
        }

        // Format time remaining
        function formatTimeRemaining(seconds) {
            const minutes = Math.ceil(seconds / 60);
            return `NEXT TRANSMISSION: <${minutes} MINUTES`;
        }

        // Update timer
        function updateTimer() {
            if (video.duration && !isNaN(video.duration)) {
                const remaining = video.duration - video.currentTime;
                timerElement.textContent = formatTimeRemaining(remaining);
            }
        }

        // Video ended - advance to next
        video.addEventListener('ended', () => {
            currentIndex = (currentIndex + 1) % transmissions.length;
            loadTransmission(currentIndex);
        });

        // Update timer every second
        video.addEventListener('timeupdate', updateTimer);

        // Handle metadata loaded
        video.addEventListener('loadedmetadata', updateTimer);

        // Error handling with detailed debugging
        video.addEventListener('error', (e) => {
            console.error('=== VIDEO ERROR ===');
            console.error('Error event:', e);
            console.error('Video error code:', video.error ? video.error.code : 'unknown');
            console.error('Video error message:', video.error ? video.error.message : 'unknown');
            console.error('Current source:', video.currentSrc);
            console.error('Video src attribute:', video.src);
            console.error('Network state:', video.networkState);
            console.error('Ready state:', video.readyState);

            // Also check source element errors
            const sources = video.querySelectorAll('source');
            sources.forEach((source, i) => {
                console.error(`Source ${i} src:`, source.src);
                console.error(`Source ${i} type:`, source.type);
            });
        });

        video.addEventListener('loadstart', () => {
            console.log('✓ Video load started:', video.src || video.currentSrc);
        });

        video.addEventListener('canplay', () => {
            console.log('✓ Video can play - ready to start');
        });

        video.addEventListener('playing', () => {
            console.log('✓ Video is NOW PLAYING');
        });

        video.addEventListener('loadeddata', () => {
            console.log('✓ Video data loaded');
        });


        // Global keyboard shortcut - press 'N' to skip to next transmission
        // Works at any time during playback
        console.log('Setting up keyboard listener for N key');

        window.addEventListener('keydown', (e) => {
            console.log('Key pressed:', e.key, 'Code:', e.code);

            // Check if 'N' key is pressed (case insensitive)
            if (e.key === 'n' || e.key === 'N' || e.code === 'KeyN') {
                e.preventDefault(); // Prevent any default behavior
                e.stopPropagation(); // Stop event from bubbling

                console.log('N key detected! Advancing to next transmission');
                console.log('Current index before:', currentIndex);

                currentIndex = (currentIndex + 1) % transmissions.length;

                console.log('Current index after:', currentIndex);
                loadTransmission(currentIndex);
            }
        }, true); // Use capture phase to ensure it fires first

        console.log('Keyboard listener active');
    </script>
</body>
</html>

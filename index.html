<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE TRANSMISSION HYPOTHESIS</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;700&display=swap" rel="stylesheet">

    <!-- Default Statcounter code for The Transmission Hypothesis https://dgbenner.github.io/the-transmission-hypothesis -->
    <script type="text/javascript">
    var sc_project=13193090;
    var sc_invisible=1;
    var sc_security="687ad2ab";
    </script>
    <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
    <noscript><div class="statcounter"><a title="website statistics" href="https://statcounter.com/" target="_blank"><img class="statcounter" src="https://c.statcounter.com/13193090/0/687ad2ab/1/" alt="website statistics" referrerPolicy="no-referrer-when-downgrade"></a></div></noscript>
    <!-- End of Statcounter Code -->

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000000;
            color: #00FF00;
            font-family: 'IBM Plex Mono', monospace;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        /* Curtain background moved to .video-container */

        /* CRT scanline effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(0, 255, 0, 0.02) 50%,
                rgba(0, 0, 0, 0.02) 50%
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 1000;
        }

        /* CRT flicker effect */
        @keyframes flicker {
            0% { opacity: 0.97; }
            50% { opacity: 1; }
            100% { opacity: 0.97; }
        }

        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 255, 0, 0.03);
            pointer-events: none;
            z-index: 999;
            animation: flicker 0.15s infinite;
        }

        .header {
            text-align: center;
            padding: 1rem 1rem 0.67rem;
            border-bottom: 2px solid #00FF00;
            position: relative;
            z-index: 10;
            flex-shrink: 0;
        }

        .status {
            font-size: 0.875rem;
            letter-spacing: 0.2em;
            margin-bottom: 0.33rem;
            display: flex;
            justify-content: center;
            gap: 2rem;
        }

        .now-playing {
            font-size: 1.1rem;
            letter-spacing: 0.1em;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .meta {
            font-size: 0.675rem;
            letter-spacing: 0.15em;
            display: flex;
            justify-content: center;
            gap: 2rem;
        }

        .video-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            position: relative;
            z-index: 10;
            min-height: 0;
            overflow: hidden;
        }

        .video-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('img/pngtree-d-illustration-of-a-theater-stage-with-black-velvet-curtains-and-picture-image_5805667.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            opacity: 0.2;
            z-index: -1;
        }

        video, iframe {
            max-width: 100%;
            max-height: 100%;
            min-width: 600px;
            min-height: 400px;
            width: auto;
            height: auto;
            object-fit: cover;
            border: 2px solid #333333;
            border-radius: 12px;
            filter: contrast(1.1) brightness(0.95);
            box-shadow: 0 0 20px rgba(51, 51, 51, 0.3);
        }

        iframe {
            width: 100%;
            height: 100%;
            min-height: 500px;
        }

        /* Hide border for very small videos (audio players) */
        @media (max-width: 768px) {
            video, iframe {
                min-width: 100%;
                min-height: 300px;
            }
        }

        @media (max-width: 480px) {
            video, iframe {
                min-width: 100%;
                min-height: 200px;
            }
        }

        /* Remove ALL video controls */
        video::-webkit-media-controls {
            display: none !important;
            -webkit-appearance: none !important;
        }

        video::-webkit-media-controls-enclosure {
            display: none !important;
        }

        video::-webkit-media-controls-panel {
            display: none !important;
        }

        video::-webkit-media-controls-play-button {
            display: none !important;
        }

        video::-webkit-media-controls-timeline {
            display: none !important;
        }

        video::-webkit-media-controls-current-time-display {
            display: none !important;
        }

        video::-webkit-media-controls-time-remaining-display {
            display: none !important;
        }

        video::-webkit-media-controls-mute-button {
            display: none !important;
        }

        video::-webkit-media-controls-volume-slider {
            display: none !important;
        }

        video::-webkit-media-controls-fullscreen-button {
            display: none !important;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .status {
                font-size: 0.75rem;
            }

            .now-playing {
                font-size: 0.95rem;
            }

            .meta {
                font-size: 0.75rem;
                gap: 1rem;
            }

            .header {
                padding: 1rem 0.5rem 0.75rem;
            }
        }

        @media (max-width: 480px) {
            .status {
                font-size: 0.625rem;
            }

            .now-playing {
                font-size: 0.8rem;
            }

            .meta {
                font-size: 0.625rem;
                flex-direction: column;
                gap: 0.25rem;
            }
        }

        /* Text glow effect */
        /* Slow pulsing glow for the status indicator */
        @keyframes slow-glow {
            0% {
                text-shadow: 0 0 6px rgba(0,255,0,0.5), 0 0 20px rgba(0,255,0,0.05);
                opacity: 0.9;
                filter: brightness(0.9);
            }
            50% {
                text-shadow: 0 0 18px rgba(0,255,0,1), 0 0 40px rgba(0,255,0,0.15);
                opacity: 1;
                filter: brightness(1.05);
            }
            100% {
                text-shadow: 0 0 6px rgba(0,255,0,0.5), 0 0 20px rgba(0,255,0,0.05);
                opacity: 0.9;
                filter: brightness(0.9);
            }
        }

        .status {
            animation: slow-glow 12s ease-in-out infinite;
        }

        .now-playing,
        .meta {
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
        }

        /* Connection overlay */
        #connectionOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000000;
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: opacity 0.8s ease-out;
        }

        #connectionOverlay.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        #connectionMessage {
            font-size: 1.5rem;
            letter-spacing: 0.3em;
            text-align: center;
            text-shadow: 0 0 20px rgba(0, 255, 0, 1);
            animation: slow-glow 4s ease-in-out infinite;
        }

        @media (max-width: 768px) {
            #connectionMessage {
                font-size: 1.1rem;
                letter-spacing: 0.2em;
            }
        }

        @media (max-width: 480px) {
            #connectionMessage {
                font-size: 0.9rem;
                letter-spacing: 0.15em;
            }
        }

        /* Glitch transition overlay */
        #glitchOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5000;
            pointer-events: none;
            opacity: 0;
            background: #000000;
        }

        #glitchOverlay.active {
            opacity: 1;
        }

        /* Glitch effect variations */
        @keyframes scanlines {
            0% { transform: translateY(0); }
            100% { transform: translateY(100%); }
        }

        @keyframes rgb-split {
            0% { transform: translate(0, 0); }
            25% { transform: translate(-5px, 2px); }
            50% { transform: translate(5px, -2px); }
            75% { transform: translate(-3px, -3px); }
            100% { transform: translate(0, 0); }
        }

        @keyframes static-noise {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        .glitch-scanlines::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 200%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 255, 0, 0.1) 2px,
                rgba(0, 255, 0, 0.1) 4px
            );
            animation: scanlines 0.5s linear infinite;
        }

        .glitch-rgb::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0.2);
            mix-blend-mode: screen;
            animation: rgb-split 0.3s steps(2) infinite;
        }

        .glitch-static::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200"><filter id="noise"><feTurbulence baseFrequency="0.9" numOctaves="4"/></filter><rect width="200" height="200" filter="url(%23noise)" opacity="0.4"/></svg>');
            animation: static-noise 0.2s infinite;
        }

        .glitch-flicker {
            animation: flicker 0.1s infinite;
        }

        /* Amber preview banner for upcoming events */
        .event-preview-banner {
            background-color: #FFBF00;
            color: #000000;
            text-align: center;
            padding: 0.375rem 1rem;
            border-bottom: 2px solid #CC9900;
            position: relative;
            z-index: 15;
            flex-shrink: 0;
            transition: all 0.3s ease;
        }

        /* In-progress state (event currently playing) */
        .event-preview-banner.in-progress {
            background-color: #FFF;
            border-bottom-color: #666666;
            padding: 0.2rem 1rem;
        }

        .event-preview-banner .countdown-line {
            font-size: 1rem;
            font-weight: 700;
            letter-spacing: 0.15em;
            margin-bottom: 0.175rem;
            transition: all 0.3s ease;
        }

        /* Smaller prefix text for "NEXT DESIGNATED TRANSMISSION:" */
        .event-preview-banner .countdown-line .prefix {
            font-size: 0.8rem;
            letter-spacing: 0.1125em;
        }

        /* Smaller text when in-progress */
        .event-preview-banner.in-progress .countdown-line {
            font-size: 0.5rem;
            margin-bottom: 0;
        }

        .event-preview-banner .timezone-line {
            font-size: 0.7rem;
            letter-spacing: 0.12em;
            opacity: 0.85;
            transition: all 0.3s ease;
        }

        /* Hide timezone line when in-progress */
        .event-preview-banner.in-progress .timezone-line {
            display: none;
        }

        @media (max-width: 768px) {
            .event-preview-banner .countdown-line {
                font-size: 0.85rem;
            }
            .event-preview-banner.in-progress .countdown-line {
                font-size: 0.45rem;
            }
            .event-preview-banner .timezone-line {
                font-size: 0.6rem;
            }
        }

        @media (max-width: 480px) {
            .event-preview-banner .countdown-line {
                font-size: 0.75rem;
            }
            .event-preview-banner.in-progress .countdown-line {
                font-size: 0.4rem;
            }
            .event-preview-banner .timezone-line {
                font-size: 0.55rem;
                letter-spacing: 0.08em;
            }
        }
    </style>
</head>
<body>
    <!-- Connection overlay -->
    <div id="connectionOverlay">
        <div id="connectionMessage">CLICK TO RECEIVE SIGNAL</div>
    </div>

    <!-- Event preview banner -->
    <div class="event-preview-banner" id="eventPreviewBanner">
        <div class="countdown-line" id="countdownLine">
            NEXT DESIGNATED TRANSMISSION: CALCULATING...
        </div>
        <div class="timezone-line" id="timezoneLine">
            --:-- GMT  |  --:-- EST  |  --:-- PST  |  --:-- GST  |  --:-- JST  |  --:-- AEDT
        </div>
    </div>

    <div class="header">
        <div class="status">
            <span>SIGNAL: ACTIVE</span>
            <span>FREQUENCY: <span id="frequency">540.7 MHz</span></span>
        </div>
        <div class="now-playing">TX: <span id="transmission">THETA-7 DND-87-D</span></div>
        <div class="meta">
            <span id="timer">--</span>
        </div>
    </div>

    <div class="video-container">
        <!-- Glitch transition overlay -->
        <div id="glitchOverlay"></div>

        <video id="videoPlayer" preload="auto" playsinline crossorigin="anonymous">
            Your terminal does not support video transmission.
        </video>
    </div>

    <script>
        // Generate obscured code from filename with persistent storage
        function generateCode(filename) {
            // Check if we already have a stored code for this filename
            const storedCodes = JSON.parse(localStorage.getItem('transmissionCodes') || '{}');

            if (storedCodes[filename]) {
                return storedCodes[filename];
            }

            // Remove extension
            const name = filename.replace(/\.(mp3|mp4|m4v)$/i, '');

            // Split by spaces, hyphens, or underscores
            const words = name.split(/[\s\-_]+/).filter(w => w.length > 0);

            // Create acronym from first letters
            const acronym = words.map(w => w.charAt(0).toUpperCase()).join('');

            // Generate consistent random numbers based on filename
            // Use simple hash function for consistency
            let hash = 0;
            for (let i = 0; i < filename.length; i++) {
                hash = ((hash << 5) - hash) + filename.charCodeAt(i);
                hash = hash & hash; // Convert to 32-bit integer
            }

            // Generate consistent 2-digit number (10-99)
            const num1 = (Math.abs(hash % 90) + 10).toString();

            // Generate consistent 2 alphanumeric characters
            const chars = 'ABCDEFGHIJKLMNPQRSTUVWXYZ23456789'; // Removed O, 0, 1, I for clarity
            const char1 = chars[Math.abs(hash % chars.length)];
            const char2 = chars[Math.abs((hash >> 8) % chars.length)];

            const code = `${acronym}-${num1}-${char1}${char2}`;

            // Store the generated code
            storedCodes[filename] = code;
            localStorage.setItem('transmissionCodes', JSON.stringify(storedCodes));

            return code;
        }

        // Protocol names for each transmission
        const protocols = [
            'THETA-7', 'SIGMA-3', 'ALPHA-9', 'DELTA-4', 'OMEGA-2', 'ZETA-6',
            'KAPPA-1', 'BETA-5', 'GAMMA-8', 'EPSILON-2', 'PHI-4', 'RHO-6',
            'PSI-9', 'LAMBDA-5', 'MU-8', 'NU-3', 'XI-7', 'OMICRON-4', 'PI-2',
            'TAU-6', 'UPSILON-9', 'CHI-1', 'ETA-5', 'IOTA-3'
        ];

        // Local video files in /media/video/ - these play during REGULAR ROTATION
        const videoFiles = [
            '1mposter on X Checking all the boxes httpst.co0mv8afA4tv X.mp4',
            'A Miracle 1973 Soviet Union Anatoly Petr.mp4',
            'AlexandrIa color engineering.mp4',
            'Art on Tezos on X Special Project Spotlight Dear Guests madebyoo.mp4',
            'Brian on X Flashback - MaxDrekker httpst.cotL9kc8hpoG X.mp4',
            'Broadcast and The Focus Group Investigate Wit.mp4',
            'Cigarette Nostalgia on X This news report on 1980s Valley Girl s.mp4',
            'Eduard on X This is real httpst.coKv9kpk1ZIA X.mp4',
            'El ojo del huracÃ¡n In the Eye of the Hurrican.mp4',
            'End of Broadcast Test Pattern  ABRN 6 Lis.mp4',
            'Interesting As Fuck on X This is how they imagined the world wou.mp4',
            'Jim Morrison of The Doors.mp4',
            'K.E.A on X LEnfer Henri-Georges Clouzot Seconds John Frankenheim.mp4',
            'Kat the Poet Engineer poetengineer__ X(1).mp4',
            'Kat the Poet Engineer poetengineer__ X(2).mp4',
            'Kat the Poet Engineer poetengineer__ X(4).mp4',
            'Kat the Poet Engineer poetengineer__ X(5).mp4',
            'Kat the Poet Engineer poetengineer__ X.mp4',
            'Kenny Omega vs. Haruka 2011 Japan Stardom.mp4',
            'Lets Visit The World Of The Future 1973 Unite.mp4',
            'Liquid Sky 1982 United States Slava Tsukerman.mp4',
            'Massimo on X Plasma inside the ST40 fusion reactor filmed in col.mp4',
            'Massimo on X Soprano mastery Monica Schwartz hitting high notes.mp4',
            'Max Headroom Signal Hijacking 1987.mp4',
            'MechFrog on X If we all have more children they can be put to wo.mp4',
            'Misfits Studio on X gn all and many thanks to everyone supportin.mp4',
            'Natived on X httpst.coGPTsQniKLX X(1).mp4',
            'Natived on X httpst.coGPTsQniKLX X.mp4',
            'Phase IV 1974 US-UK Saul Bass sound on httpst.mp4',
            'Professor Balthazar - Starlight Serenaders 19.mp4',
            'Reptile Hybrid on X rocknrollofall httpst.coNU6HUNXygG X.mp4',
            'SanDiegoHumor on X This is how my co-workers think I work remote.mp4',
            'School of the Holy Beast 1974 Suspiria 1977 s.mp4',
            'Science girl on X This chimpanzee completes a visual memory test.mp4',
            'Slava3ngl on X GMï¸ My new GIF project live on dropdotart Wire-sc.mp4',
            'Strano on X Quote with an artwork that is always on your mind. h(1).mp4',
            'Strano on X Quote with an artwork that is always on your mind. h(2).mp4',
            'Strano on X Quote with an artwork that is always on your mind. h(3).mp4',
            'Strano on X Quote with an artwork that is always on your mind. h.mp4',
            'Strano on X dreaming in colors httpst.copdoIjiO8Rb X(1).mp4',
            'Strano on X dreaming in colors httpst.copdoIjiO8Rb X.mp4',
            'The Death of Muffinhead.mp4',
            'The Door with Dr. Jack Kevorkian.mp4',
            'The Holy Mountain 1973 Mexico Alejandro Jodor(1).mp4',
            'The Holy Mountain 1973 Mexico Alejandro Jodor.mp4',
            'VD Hotline.mp4',
            'War Is Menstrual Envy 1992 United States Nick.mp4',
            'William S. Burroughs talks about Writing and Art.mp4',
            'angel dogs.mp4',
            'anti drug public service message .mp4',
            'cafe flesh pruto foridideio 1982 United Stat.mp4',
            'carnival of souls 1962).mp4',
            'cattledesert.mp4',
            'charlesmasonwhoishe.mp4',
            'czechinthenavy.mp4',
            'defragged.mp4',
            'dont Buy on X exit.mp4',
            'dont Buy on X.mp4',
            'ertdfgcvb ð“…° ð“…¬ ð“…­ ð“…® ð“…¯ on X Unminted Quine from the SVG series.mp4',
            'ex_mortal_ on X Éª á´ á´€ É¢ á´‡ httpst.coDvbSThFYSq X.mp4',
            'german teletext adult mix.mp4',
            'join us.mp4',
            'kandinsky.mp4',
            'les conflit de etoile.mp4',
            'life is flashing before your eyes.mp4',
            'metalpolymer conductor.mp4',
            'monkey doddle les elton.mp4',
            'nagels classic.mp4',
            'nightbreed.mp4',
            'nike max jean luc godard.mp4',
            'oz Film Manufacturing Company Logo 1914 Unite.mp4',
            'perfectloop on X ðš›ðšŽðšŒðšðšŽðš httpst.cofoiRFu16ah X.mp4',
            'psychotronica on X End of Day Sign-Off 1990 American Exxxtasy so.mp4',
            'psychotronica on X Shoplifters The Criminal Hordes 1983 United S.mp4',
            'rainbow-obsidian.mp4',
            'rothkovapor.mp4',
            'simpsontravelfuture.mp4',
            'sine on X Storm Cell fellowshiptrust.mp4',
            'skin tight.mp4',
            'slam dance.mp4',
            'smokingart.mp4',
            'sound check on mirror .mp4',
            'station duspute 1979.mp4',
            'stranger things sphere.mp4',
            'test pattern the police.mp4',
            'the day after.m4v',
            'the vampira show los anglesl.mp4',
            'the wizard of gore.mp4',
            'this is a test.mp4',
            'throbbing gristle discipline kazar pavillion.mp4',
            'wheeless truck walking vehicle prototype m.mp4',
            'winnebagoman.mp4',
            'woodstock.mp4',
            'ãŠã‹ãš OKAZZ on X httpst.cogWWooeMguX X.mp4',
            'Dudes Posting Their Ws on X This guy on IG makes stop-motion ani.mp4',
            'Waleed on X historyinmemes Sketch of the Maginot Line from aroun.mp4',
            'allegro non troppo.mp4',
            'apple face ID.mp4',
            'egg art in ukraine.mp4',
            'kate bush on synth and scifi.mp4',
            'snake commercial.mp4',
            'bikiniatoll.mp4',
            'breathtaking spectacle of colossal waves cras.mp4',
            'goat dopamine.mp4',
            'mermaid lagoon in peter pan 1953.mp4',
            'soft continuum 2 vivacity .mp4',
            'stonehenge - Search X.mp4',
            'virtual steps.mp4',
            'wind was so strong that it blows wat.mp4',
            'young_lovers.mpg'
        ];

        // KLING AI video files in /media/video-kling/ - these play during REGULAR ROTATION
        const klingVideoFiles = [
            'KL 2001 kubrick.mp4',
            'KL barrylyndon.mp4',
            'KL big wheel.mp4',
            'KL hallway.mp4',
            'KL shining floor.mp4',
            'ai_gen1.mp4',
            'ai_gen2.mp4',
            'ai_gen3.mp4',
            'ai_gen4.mp4',
            'ai_gen5.mp4',
            'ai_gen6.mp4',
            'ai_gen7.mp4',
            'ai_gen8.mp4',
            'ai_gen9.mp4',
            'ai_gen10.mp4',
            'ai_gen11.mp4',
            'ai_gen12.mp4',
            'ai_gen13.mp4',
            'ai_gen14.mp4',
            'ai_gen15.mp4',
            'kl space station runway.mp4',
            'klMonet valley cruese.mp4',
            'kling_20251218_Image_to_Video_Animate_th_3308_0.mp4',
            'kling_20251218_Image_to_Video_Animate_th_3336_0.mp4',
            'kling_20251218_Image_to_Video_Animate_th_3340_0.mp4',
            'kling_20251218_Image_to_Video_Animate_th_3369_0.mp4',
            'kling_20251218_Image_to_Video_Animate_th_3388_0.mp4',
            'klmonet westminstermp4.mp4'
        ];

        // Shuffle array function (Fisher-Yates shuffle)
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Load scheduled events from data/events.json
        let scheduledEvents = [];

        fetch('data/events.json')
            .then(response => response.json())
            .then(events => {
                scheduledEvents = events;
                console.log('Loaded scheduled events:', scheduledEvents.length);
                console.log('Events:', scheduledEvents);
            })
            .catch(error => {
                console.log('No scheduled events file found or error loading:', error);
                scheduledEvents = [];
            });

        // Event scheduling system
        // Event windows: 00:00 GMT, 08:00 GMT, 16:00 GMT
        const EVENT_SLOTS = [
            { hour: 0, name: 'slot-1-midnight' },
            { hour: 8, name: 'slot-2-morning' },
            { hour: 16, name: 'slot-3-afternoon' }
        ];

        // Determine current event window (if any)
        function getCurrentEventSlot() {
            const now = new Date();
            const gmtHour = now.getUTCHours();

            console.log('=== EVENT SCHEDULING CHECK ===');
            console.log('Current GMT time:', now.toUTCString());
            console.log('Current GMT hour:', gmtHour);

            // Find which event slot we're in (if any)
            for (let i = 0; i < EVENT_SLOTS.length; i++) {
                const slot = EVENT_SLOTS[i];
                if (gmtHour === slot.hour) {
                    console.log(`âœ“ IN EVENT WINDOW: ${slot.name} (${slot.hour}:00 GMT)`);
                    return { slotIndex: i, slot: slot };
                }
            }

            console.log('âœ— Not in event window, using regular rotation');
            return null;
        }

        // Select random event for current slot
        function selectEventForSlot(slotIndex) {
            if (!scheduledEvents || scheduledEvents.length === 0) {
                console.log('No events available');
                return null;
            }

            // Seed random selection based on slot and date to ensure same event for whole hour
            const now = new Date();
            const dateString = `${now.getUTCFullYear()}-${now.getUTCMonth()}-${now.getUTCDate()}`;
            const seedString = `${dateString}-slot-${slotIndex}`;

            // Simple hash function for consistent randomness
            let hash = 0;
            for (let i = 0; i < seedString.length; i++) {
                hash = ((hash << 5) - hash) + seedString.charCodeAt(i);
                hash = hash & hash;
            }

            const eventIndex = Math.abs(hash) % scheduledEvents.length;
            const selectedEvent = scheduledEvents[eventIndex];

            console.log('Event selection seed:', seedString);
            console.log('Selected event index:', eventIndex);
            console.log('Selected event:', selectedEvent);

            return selectedEvent;
        }

        // Check if we should load an event instead of regular rotation
        let currentEvent = null;
        let isEventActive = false;
        let currentEventStartTime = null;
        let broadcastMonitorInterval = null;

        /**
         * Calculate current playback position for synchronized broadcast
         * @param {Date} eventStartTime - When event began (GMT)
         * @param {number} videoDuration - Total video length in seconds
         * @returns {number|null} - Seconds to seek to, or null if event over
         */
        function calculateBroadcastPosition(eventStartTime, videoDuration) {
            const now = new Date();
            const elapsedSeconds = (now - eventStartTime) / 1000;

            console.log('=== BROADCAST SYNC CALCULATION ===');
            console.log('Event start time:', eventStartTime.toUTCString());
            console.log('Current time:', now.toUTCString());
            console.log('Elapsed seconds:', elapsedSeconds.toFixed(1));
            console.log('Video duration:', videoDuration.toFixed(1));

            // Event hasn't started yet
            if (elapsedSeconds < 0) {
                console.log('Event has not started yet');
                return 0; // Wait at beginning
            }

            // Event has ended
            if (elapsedSeconds >= videoDuration) {
                console.log('Event has already ended');
                return null; // Exit event mode
            }

            // Event in progress
            console.log('Event in progress - seek to:', elapsedSeconds.toFixed(1));
            return elapsedSeconds;
        }

        /**
         * Monitor broadcast and exit when event ends
         */
        function monitorBroadcastEnd(eventStartTime, videoDuration) {
            // Clear any existing monitor
            if (broadcastMonitorInterval) {
                clearInterval(broadcastMonitorInterval);
            }

            broadcastMonitorInterval = setInterval(() => {
                const video = document.querySelector('#videoPlayer');
                if (!video) return;

                const position = calculateBroadcastPosition(eventStartTime, videoDuration);

                if (position === null) {
                    // Broadcast has ended
                    console.log('=== BROADCAST ENDED ===');
                    clearInterval(broadcastMonitorInterval);
                    broadcastMonitorInterval = null;

                    // Exit event mode and return to regular rotation
                    isEventActive = false;
                    currentEvent = null;
                    currentEventStartTime = null;

                    // Show glitch transition and load next transmission
                    showGlitchTransition(() => {
                        currentIndex = (currentIndex + 1) % transmissions.length;
                        loadTransmission(currentIndex);
                    });
                }
            }, 10000); // Check every 10 seconds
        }

        function checkForEvent() {
            const eventSlot = getCurrentEventSlot();

            if (eventSlot) {
                const event = selectEventForSlot(eventSlot.slotIndex);
                if (event) {
                    currentEvent = event;
                    isEventActive = true;

                    // Set event start time to current hour at :00:00
                    if (!currentEventStartTime) {
                        currentEventStartTime = new Date();
                        currentEventStartTime.setUTCMinutes(0, 0, 0);
                        console.log('âœ“ EVENT MODE ACTIVE - Start time:', currentEventStartTime.toUTCString());
                    }

                    return true;
                }
            }

            isEventActive = false;
            currentEvent = null;
            currentEventStartTime = null;
            console.log('âœ“ REGULAR ROTATION MODE');
            return false;
        }

        // Event preview banner logic
        const eventBanner = document.getElementById('eventPreviewBanner');
        const countdownLine = document.getElementById('countdownLine');
        const timezoneLine = document.getElementById('timezoneLine');

        // Find next upcoming event slot
        function getNextEventSlot() {
            const now = new Date();
            const gmtHour = now.getUTCHours();
            const gmtMinutes = now.getUTCMinutes();

            // Find the next event slot
            for (let i = 0; i < EVENT_SLOTS.length; i++) {
                const slot = EVENT_SLOTS[i];
                if (slot.hour > gmtHour || (slot.hour === gmtHour && gmtMinutes === 0)) {
                    return { slotIndex: i, slot: slot };
                }
            }

            // If we're past all slots today, next event is tomorrow's first slot
            return { slotIndex: 0, slot: EVENT_SLOTS[0] };
        }

        // Format countdown timer
        function formatCountdown(milliseconds) {
            const totalMinutes = Math.floor(milliseconds / 60000);
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;

            if (hours > 0) {
                return `${hours}H ${minutes}M`;
            } else {
                return `${minutes}M`;
            }
        }

        // Helper function to format time with lowercase a/p for am/pm
        function formatTime12Hour(hour24) {
            if (hour24 === 0) return '12:00a';
            if (hour24 < 12) return `${hour24}:00a`;
            if (hour24 === 12) return '12:00p';
            return `${hour24 - 12}:00p`;
        }

        // Convert GMT hour to other timezones
        function formatTimezones(gmtHour) {
            const now = new Date();
            const baseDate = new Date(now);
            baseDate.setUTCHours(gmtHour, 0, 0, 0);

            // If the event is tomorrow (we're past all today's slots), add a day
            const currentSlot = getNextEventSlot();
            if (currentSlot.slotIndex === 0 && gmtHour === 0 && now.getUTCHours() > 16) {
                baseDate.setUTCDate(baseDate.getUTCDate() + 1);
            }

            // Format each timezone with 12-hour format and lowercase a/p
            const gmtTime = `${formatTime12Hour(gmtHour)} GMT`;

            // EST (UTC-5)
            const estDate = new Date(baseDate.getTime() - 5 * 60 * 60 * 1000);
            const estTime = `${formatTime12Hour(estDate.getUTCHours())} EST`;

            // PST (UTC-8)
            const pstDate = new Date(baseDate.getTime() - 8 * 60 * 60 * 1000);
            const pstTime = `${formatTime12Hour(pstDate.getUTCHours())} PST`;

            // GST (UTC+4)
            const gstDate = new Date(baseDate.getTime() + 4 * 60 * 60 * 1000);
            const gstTime = `${formatTime12Hour(gstDate.getUTCHours())} GST`;

            // JST (UTC+9)
            const jstDate = new Date(baseDate.getTime() + 9 * 60 * 60 * 1000);
            const jstTime = `${formatTime12Hour(jstDate.getUTCHours())} JST`;

            // AEDT (UTC+11)
            const aedtDate = new Date(baseDate.getTime() + 11 * 60 * 60 * 1000);
            const aedtTime = `${formatTime12Hour(aedtDate.getUTCHours())} AEDT`;

            return `${gmtTime}  |  ${estTime}  |  ${pstTime}  |  ${gstTime}  |  ${jstTime}  |  ${aedtTime}`;
        }

        // Update event preview banner
        function updateEventPreview() {
            // Check if an event is currently active
            if (isEventActive && currentEvent) {
                // IN-PROGRESS MODE: Event is currently playing
                eventBanner.classList.add('in-progress');
                countdownLine.textContent = `DESIGNATED TRANSMISSION: ${currentEvent.title}`;
                // Timezone line will be hidden by CSS
            } else {
                // PREVIEW MODE: Show upcoming event
                eventBanner.classList.remove('in-progress');

                const nextSlot = getNextEventSlot();
                const now = new Date();

                // Calculate time until next event
                const targetDate = new Date(now);
                targetDate.setUTCHours(nextSlot.slot.hour, 0, 0, 0);

                // If target is in the past today, it's tomorrow
                if (targetDate <= now) {
                    targetDate.setUTCDate(targetDate.getUTCDate() + 1);
                }

                const timeUntilEvent = targetDate - now;

                // Get the event that will play in this slot
                const upcomingEvent = selectEventForSlot(nextSlot.slotIndex);
                const eventTitle = upcomingEvent ? upcomingEvent.title : 'SCHEDULED PROGRAMMING';

                // Update countdown line with smaller prefix text
                const countdown = formatCountdown(timeUntilEvent);
                countdownLine.innerHTML = `<span class="prefix">NEXT DESIGNATED TRANSMISSION</span> ${eventTitle}  |  <span class="prefix">BEGINS IN</span> <span class="prefix">${countdown}</span>`;

                // Update timezone line
                timezoneLine.textContent = formatTimezones(nextSlot.slot.hour);
            }
        }

        // Update banner every second
        setInterval(updateEventPreview, 1000);

        // Initial update when events are loaded
        setTimeout(updateEventPreview, 500);

        // Generate transmissions for REGULAR ROTATION (local files ONLY)
        // Scheduled events from events.json are handled separately
        let transmissions = [];

        // Generate transmissions from local video files
        const localTransmissions = videoFiles.map((filename, index) => {
            // Create title from filename
            const title = filename
                .replace(/\.(mp4|m4v)$/i, '')
                .split(/[\s\-_]+/)
                .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                .join(' ');

            const code = generateCode(filename);

            return {
                title: title,
                url: `media/video/${filename}`,
                protocol: protocols[index % protocols.length],
                code: code,
                source: 'local'
            };
        });

        // Generate transmissions from KLING video files
        const klingTransmissions = klingVideoFiles.map((filename, index) => {
            // Create title from filename
            const title = filename
                .replace(/\.(mp4|m4v)$/i, '')
                .split(/[\s\-_]+/)
                .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                .join(' ');

            const code = generateCode(filename);

            return {
                title: title,
                url: `media/video-kling/${filename}`,
                protocol: protocols[(videoFiles.length + index) % protocols.length],
                code: code,
                source: 'kling'
            };
        });

        // Combine and shuffle for regular rotation
        const allTransmissions = [...localTransmissions, ...klingTransmissions];
        transmissions = shuffleArray(allTransmissions);

        console.log('=== REGULAR ROTATION INITIALIZED ===');
        console.log('Total transmissions:', transmissions.length);
        console.log(`Local: ${localTransmissions.length}, KLING: ${klingTransmissions.length}`);
        console.log('Transmissions (randomized):', transmissions);
        console.log('Transmissions ready, waiting for user connection...');
        console.log('');
        console.log('NOTE: Scheduled events from events.json play at 00:00, 08:00, 16:00 GMT');

        let currentIndex = 0;
        const video = document.getElementById('videoPlayer');
        const transmissionElement = document.getElementById('transmission');
        const timerElement = document.getElementById('timer');
        const frequencyElement = document.getElementById('frequency');
        const connectionOverlay = document.getElementById('connectionOverlay');
        const connectionMessage = document.getElementById('connectionMessage');
        const glitchOverlay = document.getElementById('glitchOverlay');

        // Glitch effect types
        const glitchTypes = ['glitch-scanlines', 'glitch-rgb', 'glitch-static', 'glitch-flicker'];

        // Create audio context for glitch sounds
        let audioContext = null;

        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        // Generate glitch audio effects
        function playGlitchSound() {
            initAudioContext();

            const duration = 0.3 + Math.random() * 0.3; // 0.3-0.6 seconds
            const now = audioContext.currentTime;

            // Random glitch sound type
            const glitchType = Math.floor(Math.random() * 3);

            if (glitchType === 0) {
                // Static burst
                const bufferSize = audioContext.sampleRate * duration;
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * 0.3; // White noise at 30% volume
                }
                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                const gainNode = audioContext.createGain();
                gainNode.gain.setValueAtTime(0.3, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + duration);
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                source.start(now);
                source.stop(now + duration);
            } else if (glitchType === 1) {
                // VHS squeal (high frequency sweep)
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(2000, now);
                oscillator.frequency.exponentialRampToValueAtTime(500, now + duration);
                gainNode.gain.setValueAtTime(0.15, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + duration);
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.start(now);
                oscillator.stop(now + duration);
            } else {
                // Digital glitch (rapid frequency jumps)
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.type = 'square';
                const baseFreq = 100 + Math.random() * 200;
                oscillator.frequency.setValueAtTime(baseFreq, now);
                oscillator.frequency.setValueAtTime(baseFreq * 2, now + duration / 3);
                oscillator.frequency.setValueAtTime(baseFreq * 0.5, now + duration * 2 / 3);
                gainNode.gain.setValueAtTime(0.2, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + duration);
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.start(now);
                oscillator.stop(now + duration);
            }
        }

        // Show glitch transition
        function showGlitchTransition(callback) {
            // Random glitch type
            const glitchClass = glitchTypes[Math.floor(Math.random() * glitchTypes.length)];
            const duration = 300 + Math.random() * 500; // 0.3-0.8 seconds

            // Add glitch class and activate
            glitchOverlay.className = glitchClass;
            glitchOverlay.classList.add('active');

            // Play glitch sound
            playGlitchSound();

            // Remove glitch after duration
            setTimeout(() => {
                glitchOverlay.classList.remove('active');
                setTimeout(() => {
                    glitchOverlay.className = '';
                    if (callback) callback();
                }, 100);
            }, duration);
        }

        // Handle connection overlay
        let connectionEstablished = false;

        connectionOverlay.addEventListener('click', () => {
            if (!connectionEstablished) {
                connectionEstablished = true;

                // Initialize audio context on first user interaction
                initAudioContext();

                // Change message to "SIGNAL RECEIVED"
                connectionMessage.textContent = 'SIGNAL RECEIVED';

                // Load first transmission
                loadTransmission(currentIndex);

                // After 1.5 seconds, fade out overlay and start video
                setTimeout(() => {
                    connectionOverlay.classList.add('fade-out');

                    // Start video playback
                    video.play().catch(err => {
                        console.error('Play failed after connection:', err);
                    });

                    // Remove overlay from DOM after fade completes
                    setTimeout(() => {
                        connectionOverlay.remove();
                    }, 800); // Match the CSS transition duration
                }, 1500);
            }
        });

        // Frequency drift system
        const BASE_FREQUENCY = 540.7;
        let currentFrequency = BASE_FREQUENCY;
        let targetFrequency = BASE_FREQUENCY;
        let driftState = 'stable'; // 'stable', 'small-drift', 'spike'
        let driftEndTime = 0;

        function updateFrequency() {
            const now = Date.now();

            // Check if current drift/spike has ended
            if (driftState !== 'stable' && now >= driftEndTime) {
                // Return to base frequency
                driftState = 'stable';
                targetFrequency = BASE_FREQUENCY;
            }

            // When stable, randomly trigger drifts or spikes
            if (driftState === 'stable') {
                const rand = Math.random();

                // 2-3 large spikes per minute = ~3-4% chance per second
                if (rand < 0.035) {
                    driftState = 'spike';
                    // Randomly choose drop or spike
                    targetFrequency = Math.random() < 0.5 ? 538.2 : 541.9;
                    // Duration: 0.5-1.5 seconds
                    driftEndTime = now + (500 + Math.random() * 1000);
                }
                // 4-6 small drifts per minute = ~8-10% chance per second
                else if (rand < 0.10) {
                    driftState = 'small-drift';
                    // Drift between 540.5 - 540.9
                    targetFrequency = 540.5 + Math.random() * 0.4;
                    // Duration: 4-10 seconds
                    driftEndTime = now + (4000 + Math.random() * 6000);
                }
            }

            // Smoothly interpolate current frequency toward target
            const drift = targetFrequency - currentFrequency;
            if (Math.abs(drift) > 0.01) {
                // Spikes are faster, drifts are slower
                const speed = driftState === 'spike' ? 0.3 : 0.05;
                currentFrequency += drift * speed;
            } else {
                currentFrequency = targetFrequency;
            }

            // Update display
            frequencyElement.textContent = `${currentFrequency.toFixed(1)} MHz`;
        }

        // Update frequency every 100ms for smooth animation
        setInterval(updateFrequency, 100);

        // Manual event trigger - select random event from pool
        function triggerManualEvent() {
            if (!scheduledEvents || scheduledEvents.length === 0) {
                console.log('No events available for manual trigger');
                return null;
            }

            // Find events that are NOT the current event
            let availableEvents = scheduledEvents;
            if (currentEvent) {
                availableEvents = scheduledEvents.filter(e => e !== currentEvent);
            }

            // If we filtered down to nothing, use the full list
            if (availableEvents.length === 0) {
                availableEvents = scheduledEvents;
            }

            // Pick random event
            const randomIndex = Math.floor(Math.random() * availableEvents.length);
            const selectedEvent = availableEvents[randomIndex];

            console.log('Manual event selection - available events:', availableEvents.length);
            console.log('Selected event:', selectedEvent);

            return selectedEvent;
        }

        // Load transmission
        // Helper function to extract Archive.org item ID from URL
        function getArchiveItemId(url) {
            // Match patterns like:
            // https://archive.org/download/ITEM-ID/...
            // https://dn710105.ca.archive.org/0/items/ITEM-ID/...
            const downloadMatch = url.match(/archive\.org\/download\/([^\/]+)/);
            const itemsMatch = url.match(/archive\.org\/\d+\/items\/([^\/]+)/);

            if (downloadMatch) return downloadMatch[1];
            if (itemsMatch) return itemsMatch[1];
            return null;
        }

        // Helper function to check if URL is Archive.org
        function isArchiveUrl(url) {
            return url.includes('archive.org');
        }

        function loadTransmission(index, skipEventCheck = false) {
            // Check if we should load an event instead (unless manually triggered)
            if (!skipEventCheck) {
                checkForEvent();
            }

            let transmission;
            let isEvent = false;

            if (isEventActive && currentEvent) {
                // Load event video
                console.log('=== LOADING EVENT ===');
                console.log('Event:', currentEvent);

                transmission = {
                    title: currentEvent.title,
                    url: currentEvent.url,
                    protocol: 'EVENT',
                    code: currentEvent.category ? currentEvent.category.toUpperCase() : 'SPECIAL',
                    source: 'event'
                };
                isEvent = true;
            } else {
                // Load regular rotation video
                transmission = transmissions[index];
                console.log(`Loading transmission ${index + 1}/${transmissions.length}:`, transmission);
            }

            const videoContainer = document.querySelector('.video-container');

            // Check if URL is Archive.org
            if (isArchiveUrl(transmission.url)) {
                console.log('Archive.org URL detected - using iframe embed');

                const itemId = getArchiveItemId(transmission.url);
                if (itemId) {
                    console.log('Item ID:', itemId);
                    const embedUrl = `https://archive.org/embed/${itemId}`;
                    console.log('Embed URL:', embedUrl);

                    // Remove existing video element
                    const existingVideo = videoContainer.querySelector('#videoPlayer');
                    if (existingVideo) {
                        existingVideo.remove();
                    }

                    // Remove existing iframe if any
                    const existingIframe = videoContainer.querySelector('iframe');
                    if (existingIframe) {
                        existingIframe.remove();
                    }

                    // Create new iframe
                    const iframe = document.createElement('iframe');
                    iframe.id = 'archiveEmbed';
                    iframe.src = embedUrl;
                    iframe.frameborder = '0';
                    iframe.allowfullscreen = true;
                    iframe.allow = 'fullscreen';

                    // Insert iframe after glitch overlay
                    const glitchOverlay = videoContainer.querySelector('#glitchOverlay');
                    if (glitchOverlay) {
                        glitchOverlay.insertAdjacentElement('afterend', iframe);
                    } else {
                        videoContainer.appendChild(iframe);
                    }

                    console.log('âœ“ Archive.org iframe loaded');
                } else {
                    console.error('Could not extract item ID from Archive.org URL');
                }
            } else {
                // Detect if this is a Cloudflare R2 URL or local file
                const isCloudflare = transmission.url.includes('r2.dev') || transmission.url.includes('cloudflare');
                if (isCloudflare) {
                    console.log('Cloudflare R2 URL detected - using video tag with CORS');
                } else {
                    console.log('Local file detected - using video tag');
                }
                console.log('Video URL:', transmission.url);

                // Remove existing iframe if any
                const existingIframe = videoContainer.querySelector('iframe');
                if (existingIframe) {
                    existingIframe.remove();
                }

                // Create video element if it doesn't exist
                let videoElement = videoContainer.querySelector('#videoPlayer');
                if (!videoElement) {
                    videoElement = document.createElement('video');
                    videoElement.id = 'videoPlayer';
                    videoElement.preload = 'auto';
                    videoElement.playsinline = true;
                    videoElement.crossOrigin = 'anonymous';
                    videoElement.textContent = 'Your terminal does not support video transmission.';

                    const glitchOverlay = videoContainer.querySelector('#glitchOverlay');
                    if (glitchOverlay) {
                        glitchOverlay.insertAdjacentElement('afterend', videoElement);
                    } else {
                        videoContainer.appendChild(videoElement);
                    }

                    // Re-assign video variable
                    video = videoElement;
                }

                // Clear existing source
                video.pause();
                video.removeAttribute('src');
                while (video.firstChild) {
                    video.removeChild(video.firstChild);
                }

                // Add new source
                const source = document.createElement('source');
                source.src = transmission.url;
                console.log('Setting video source to:', source.src);

                // Detect file type
                if (transmission.url.endsWith('.mp3')) {
                    source.type = 'audio/mpeg';
                } else if (transmission.url.endsWith('.mp4')) {
                    source.type = 'video/mp4';
                } else if (transmission.url.endsWith('.m4v')) {
                    source.type = 'video/mp4';
                }

                video.appendChild(source);

                // Load video
                console.log('Calling video.load()...');
                video.load();

                // Handle synchronized broadcast for events
                if (isEvent && currentEventStartTime) {
                    console.log('=== SYNCHRONIZED BROADCAST MODE ===');

                    // Wait for metadata to get video duration
                    const metadataHandler = () => {
                        const position = calculateBroadcastPosition(currentEventStartTime, video.duration);

                        if (position === null) {
                            // Event already over, exit to regular rotation
                            console.log('Event already ended, exiting to regular rotation');
                            isEventActive = false;
                            currentEvent = null;
                            currentEventStartTime = null;

                            showGlitchTransition(() => {
                                currentIndex = (currentIndex + 1) % transmissions.length;
                                loadTransmission(currentIndex);
                            });
                            return;
                        }

                        // Seek to current broadcast position
                        console.log('Seeking to broadcast position:', position.toFixed(1), 'seconds');
                        video.currentTime = position;

                        // Start playback if connection established
                        if (connectionEstablished) {
                            video.play().then(() => {
                                console.log('âœ“ Synchronized broadcast playing');
                            }).catch(err => {
                                console.error('âœ— Play failed:', err);
                            });
                        }

                        // Start monitoring for event end
                        monitorBroadcastEnd(currentEventStartTime, video.duration);

                        // Remove this listener
                        video.removeEventListener('loadedmetadata', metadataHandler);
                    };

                    video.addEventListener('loadedmetadata', metadataHandler);

                    // Timeout fallback in case metadata fails
                    setTimeout(() => {
                        if (video.duration === 0 || isNaN(video.duration)) {
                            console.error('Video metadata failed to load, exiting event mode');
                            video.removeEventListener('loadedmetadata', metadataHandler);
                            isEventActive = false;
                            currentEvent = null;
                            currentEventStartTime = null;

                            showGlitchTransition(() => {
                                currentIndex = (currentIndex + 1) % transmissions.length;
                                loadTransmission(currentIndex);
                            });
                        }
                    }, 10000); // 10 second timeout
                } else {
                    // Regular playback (non-event or non-Cloudflare)
                    if (connectionEstablished) {
                        console.log('Connection established, calling video.play()...');
                        video.play().then(() => {
                            console.log('âœ“ Video playing successfully');
                        }).catch(err => {
                            console.error('âœ— Play failed:', err);
                            console.error('Error details:', err.message, err.name);
                        });
                    } else {
                        console.log('âš  Connection not established yet, video will not autoplay');
                    }
                }

                console.log('âœ“ Video element loaded and ready');
            }

            // Update UI - combine protocol and code
            transmissionElement.textContent = `${transmission.protocol} ${transmission.code}`;
            console.log(`Display updated: ${transmission.protocol} ${transmission.code}`);
        }

        // Format time remaining
        function formatTimeRemaining(seconds) {
            const minutes = Math.ceil(seconds / 60);
            return `NEXT PACKET TRANSMITTING: <${minutes} MINUTES`;
        }

        // Update timer
        function updateTimer() {
            if (video.duration && !isNaN(video.duration)) {
                const remaining = video.duration - video.currentTime;
                timerElement.textContent = formatTimeRemaining(remaining);
            }
        }

        // Video ended - advance to next with glitch transition
        video.addEventListener('ended', () => {
            // Show glitch effect
            showGlitchTransition(() => {
                // Check if we just finished an event
                if (isEventActive) {
                    console.log('Event finished, returning to regular rotation');
                    isEventActive = false;
                    currentEvent = null;
                    currentEventStartTime = null;

                    // Clean up broadcast monitor
                    if (broadcastMonitorInterval) {
                        clearInterval(broadcastMonitorInterval);
                        broadcastMonitorInterval = null;
                    }
                }

                // After glitch, load next transmission (will check for events again)
                currentIndex = (currentIndex + 1) % transmissions.length;
                loadTransmission(currentIndex);
            });
        });

        // Update timer every second
        video.addEventListener('timeupdate', updateTimer);

        // Handle metadata loaded
        video.addEventListener('loadedmetadata', updateTimer);

        // Error handling with detailed debugging
        video.addEventListener('error', (e) => {
            console.error('=== VIDEO ERROR ===');
            console.error('Error event:', e);
            console.error('Video error code:', video.error ? video.error.code : 'unknown');
            console.error('Video error message:', video.error ? video.error.message : 'unknown');
            console.error('Current source:', video.currentSrc);
            console.error('Video src attribute:', video.src);
            console.error('Network state:', video.networkState);
            console.error('Ready state:', video.readyState);

            // Also check source element errors
            const sources = video.querySelectorAll('source');
            sources.forEach((source, i) => {
                console.error(`Source ${i} src:`, source.src);
                console.error(`Source ${i} type:`, source.type);
            });
        });

        video.addEventListener('loadstart', () => {
            console.log('âœ“ Video load started:', video.src || video.currentSrc);
        });

        video.addEventListener('canplay', () => {
            console.log('âœ“ Video can play - ready to start');
        });

        video.addEventListener('playing', () => {
            console.log('âœ“ Video is NOW PLAYING');
        });

        video.addEventListener('loadeddata', () => {
            console.log('âœ“ Video data loaded');
        });


        // Global keyboard shortcuts
        // N = skip to next regular video (or exit event mode)
        // M = trigger/skip events (manual control)
        console.log('Setting up keyboard listeners for N and M keys');

        window.addEventListener('keydown', (e) => {
            console.log('Key pressed:', e.key, 'Code:', e.code);

            // Check if 'N' key is pressed (case insensitive)
            if (e.key === 'n' || e.key === 'N' || e.code === 'KeyN') {
                e.preventDefault();
                e.stopPropagation();

                console.log('N key detected! Advancing to next transmission');
                console.log('Current index before:', currentIndex);

                // If in event mode, exit it
                if (isEventActive) {
                    console.log('Exiting event mode, returning to regular rotation');
                    isEventActive = false;
                    currentEvent = null;
                    currentEventStartTime = null;

                    // Clean up broadcast monitor
                    if (broadcastMonitorInterval) {
                        clearInterval(broadcastMonitorInterval);
                        broadcastMonitorInterval = null;
                    }
                }

                // Show glitch transition before switching
                showGlitchTransition(() => {
                    currentIndex = (currentIndex + 1) % transmissions.length;
                    console.log('Current index after:', currentIndex);
                    // Pass skipEventCheck=true to force regular rotation even during event window
                    loadTransmission(currentIndex, true);
                });
            }

            // Check if 'M' key is pressed (case insensitive)
            if (e.key === 'm' || e.key === 'M' || e.code === 'KeyM') {
                e.preventDefault();
                e.stopPropagation();

                console.log('M key detected! Manual event control');

                const event = triggerManualEvent();

                if (event) {
                    if (isEventActive) {
                        console.log(`Skipping to next event: ${event.title}`);
                    } else {
                        console.log(`Manual event trigger - playing: ${event.title}`);
                    }

                    // Set event mode and trigger event load
                    currentEvent = event;
                    isEventActive = true;

                    // Set event start time to NOW for manual triggers
                    currentEventStartTime = new Date();
                    console.log('Manual event start time:', currentEventStartTime.toUTCString());

                    // Use showGlitchTransition and loadTransmission for proper handling
                    showGlitchTransition(() => {
                        // loadTransmission will detect isEventActive and load currentEvent
                        // Pass skipEventCheck=true to prevent checkForEvent() from clearing our manual event
                        loadTransmission(currentIndex, true);
                    });
                } else {
                    console.log('No events available to trigger');
                }
            }
        }, true); // Use capture phase to ensure it fires first

        console.log('Keyboard listeners active (N = skip regular, M = events)');
    </script>
</body>
</html>

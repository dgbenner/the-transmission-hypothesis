<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE TRANSMISSION HYPOTHESIS</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000000;
            color: #00FF00;
            font-family: 'IBM Plex Mono', monospace;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* CRT scanline effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(0, 255, 0, 0.02) 50%,
                rgba(0, 0, 0, 0.02) 50%
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 1000;
        }

        /* CRT flicker effect */
        @keyframes flicker {
            0% { opacity: 0.97; }
            50% { opacity: 1; }
            100% { opacity: 0.97; }
        }

        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 255, 0, 0.03);
            pointer-events: none;
            z-index: 999;
            animation: flicker 0.15s infinite;
        }

        .header {
            text-align: center;
            padding: 1.5rem 1rem 1rem;
            border-bottom: 2px solid #00FF00;
            position: relative;
            z-index: 10;
            flex-shrink: 0;
        }

        .status {
            font-size: 0.875rem;
            letter-spacing: 0.2em;
            margin-bottom: 0.5rem;
        }

        .now-playing {
            font-size: 1.1rem;
            letter-spacing: 0.1em;
            margin-bottom: 0.75rem;
            font-weight: 600;
        }

        .meta {
            font-size: 0.875rem;
            letter-spacing: 0.15em;
            display: flex;
            justify-content: center;
            gap: 2rem;
        }

        .video-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            position: relative;
            z-index: 10;
            min-height: 0;
            overflow: hidden;
        }

        video {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain;
            border: 2px solid #00FF00;
            filter: contrast(1.1) brightness(0.95);
        }

        /* Remove ALL video controls */
        video::-webkit-media-controls {
            display: none !important;
            -webkit-appearance: none !important;
        }

        video::-webkit-media-controls-enclosure {
            display: none !important;
        }

        video::-webkit-media-controls-panel {
            display: none !important;
        }

        video::-webkit-media-controls-play-button {
            display: none !important;
        }

        video::-webkit-media-controls-timeline {
            display: none !important;
        }

        video::-webkit-media-controls-current-time-display {
            display: none !important;
        }

        video::-webkit-media-controls-time-remaining-display {
            display: none !important;
        }

        video::-webkit-media-controls-mute-button {
            display: none !important;
        }

        video::-webkit-media-controls-volume-slider {
            display: none !important;
        }

        video::-webkit-media-controls-fullscreen-button {
            display: none !important;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .status {
                font-size: 0.75rem;
            }

            .now-playing {
                font-size: 0.95rem;
            }

            .meta {
                font-size: 0.75rem;
                gap: 1rem;
            }

            .header {
                padding: 1rem 0.5rem 0.75rem;
            }
        }

        @media (max-width: 480px) {
            .status {
                font-size: 0.625rem;
            }

            .now-playing {
                font-size: 0.8rem;
            }

            .meta {
                font-size: 0.625rem;
                flex-direction: column;
                gap: 0.25rem;
            }
        }

        /* Text glow effect */
        .status,
        .now-playing,
        .meta {
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="status">SIGNAL ACTIVE</div>
        <div class="now-playing">TX: <span id="transmission">THETA-7 DND-87-D</span></div>
        <div class="meta">
            <span id="timer">--</span>
        </div>
    </div>

    <div class="video-container">
        <video id="videoPlayer" preload="auto" autoplay playsinline crossorigin="anonymous">
            Your terminal does not support video transmission.
        </video>
    </div>

    <script>
        // Generate obscured code from filename with persistent storage
        function generateCode(filename) {
            // Check if we already have a stored code for this filename
            const storedCodes = JSON.parse(localStorage.getItem('transmissionCodes') || '{}');

            if (storedCodes[filename]) {
                return storedCodes[filename];
            }

            // Remove extension
            const name = filename.replace(/\.(mp3|mp4|m4v)$/i, '');

            // Split by spaces, hyphens, or underscores
            const words = name.split(/[\s\-_]+/).filter(w => w.length > 0);

            // Create acronym from first letters
            const acronym = words.map(w => w.charAt(0).toUpperCase()).join('');

            // Generate consistent random numbers based on filename
            // Use simple hash function for consistency
            let hash = 0;
            for (let i = 0; i < filename.length; i++) {
                hash = ((hash << 5) - hash) + filename.charCodeAt(i);
                hash = hash & hash; // Convert to 32-bit integer
            }

            // Generate consistent 2-digit number (10-99)
            const num1 = (Math.abs(hash % 90) + 10).toString();

            // Generate consistent 2 alphanumeric characters
            const chars = 'ABCDEFGHIJKLMNPQRSTUVWXYZ23456789'; // Removed O, 0, 1, I for clarity
            const char1 = chars[Math.abs(hash % chars.length)];
            const char2 = chars[Math.abs((hash >> 8) % chars.length)];

            const code = `${acronym}-${num1}-${char1}${char2}`;

            // Store the generated code
            storedCodes[filename] = code;
            localStorage.setItem('transmissionCodes', JSON.stringify(storedCodes));

            return code;
        }

        // Protocol names for each transmission
        const protocols = [
            'THETA-7', 'SIGMA-3', 'ALPHA-9', 'DELTA-4', 'OMEGA-2', 'ZETA-6',
            'KAPPA-1', 'BETA-5', 'GAMMA-8', 'EPSILON-2', 'PHI-4', 'RHO-6',
            'PSI-9', 'LAMBDA-5', 'MU-8', 'NU-3', 'XI-7', 'OMICRON-4', 'PI-2',
            'TAU-6', 'UPSILON-9', 'CHI-1', 'ETA-5', 'IOTA-3'
        ];

        // Video files in /media/video/ - UPDATE THIS LIST when adding new files
        const videoFiles = [
            'anti drug public service message .mp4',
            'Broadcast and The Focus Group Investigate Wit.mp4',
            'cafe flesh pruto foridideio 1982 United Stat.mp4',
            'End of Broadcast Test Pattern  ABRN 6 Lis.mp4',
            'german teletext adult mix.mp4',
            'join us.mp4',
            'K.E.A on X LEnfer Henri-Georges Clouzot Seconds John Frankenheim.mp4',
            'Kenny Omega vs. Haruka 2011 Japan Stardom.mp4',
            'les conflit de etoile.mp4',
            'Lets Visit The World Of The Future 1973 Unite.mp4',
            'life is flashing before your eyes.mp4',
            'Liquid Sky 1982 United States Slava Tsukerman.mp4',
            'monkey doddle les elton.mp4',
            'nightbreed.mp4',
            'nike max jean luc godard.mp4',
            'oz Film Manufacturing Company Logo 1914 Unite.mp4',
            'Professor Balthazar - Starlight Serenaders 19.mp4',
            'psychotronica on X End of Day Sign-Off 1990 American Exxxtasy so.mp4',
            'psychotronica on X Shoplifters The Criminal Hordes 1983 United S.mp4',
            'skin tight.mp4',
            'slam dance.mp4',
            'sound check on mirror .mp4',
            'station duspute 1979.mp4',
            'test pattern the police.mp4',
            'the day after.m4v',
            'The Death of Muffinhead.mp4',
            'The Door with Dr. Jack Kevorkian.mp4',
            'the vampira show los anglesl.mp4',
            'the wizard of gore.mp4',
            'this is a test.mp4',
            'throbbing gristle discipline kazar pavillion.mp4'
        ];

        // Shuffle array function (Fisher-Yates shuffle)
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Load external links and combine with local files
        let transmissions = [];

        fetch('media/links.json')
            .then(response => response.json())
            .then(externalLinks => {
                console.log('Loaded external links:', externalLinks.length);

                // Generate transmissions from local video files
                const localTransmissions = videoFiles.map((filename, index) => {
                    // Create title from filename
                    const title = filename
                        .replace(/\.(mp4|m4v)$/i, '')
                        .split(/[\s\-_]+/)
                        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                        .join(' ');

                    const code = generateCode(filename);

                    return {
                        title: title,
                        url: `media/video/${filename}`,
                        protocol: protocols[index % protocols.length],
                        code: code,
                        source: 'local'
                    };
                });

                // Generate transmissions from external links
                const externalTransmissions = externalLinks.map((link, index) => {
                    const code = generateCode(link.title);

                    return {
                        title: link.title,
                        url: link.url,
                        protocol: protocols[(videoFiles.length + index) % protocols.length],
                        code: code,
                        source: 'external'
                    };
                });

                // Combine and shuffle all transmissions
                const allTransmissions = [...localTransmissions, ...externalTransmissions];
                transmissions = shuffleArray(allTransmissions);

                console.log('Total transmissions:', transmissions.length);
                console.log(`Local: ${localTransmissions.length}, External: ${externalTransmissions.length}`);
                console.log('Transmissions (randomized):', transmissions);

                // Initialize first transmission
                loadTransmission(currentIndex);
            })
            .catch(error => {
                console.error('Error loading external links, using local only:', error);

                // Fallback to local only if links.json fails to load
                const shuffledVideoFiles = shuffleArray(videoFiles);
                transmissions = shuffledVideoFiles.map((filename, index) => {
                    const title = filename
                        .replace(/\.(mp4|m4v)$/i, '')
                        .split(/[\s\-_]+/)
                        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                        .join(' ');

                    const code = generateCode(filename);

                    return {
                        title: title,
                        url: `media/video/${filename}`,
                        protocol: protocols[index % protocols.length],
                        code: code,
                        source: 'local'
                    };
                });

                console.log('Total transmissions (local only):', transmissions.length);

                // Initialize first transmission
                loadTransmission(currentIndex);
            });

        let currentIndex = 0;
        const video = document.getElementById('videoPlayer');
        const transmissionElement = document.getElementById('transmission');
        const timerElement = document.getElementById('timer');

        // Load transmission
        function loadTransmission(index) {
            const transmission = transmissions[index];
            console.log(`Loading transmission ${index + 1}/${transmissions.length}:`, transmission);

            // Clear existing source
            video.pause();
            video.removeAttribute('src');
            while (video.firstChild) {
                video.removeChild(video.firstChild);
            }

            // Add new source
            const source = document.createElement('source');
            source.src = transmission.url;

            // Detect file type
            if (transmission.url.endsWith('.mp3')) {
                source.type = 'audio/mpeg';
            } else if (transmission.url.endsWith('.mp4')) {
                source.type = 'video/mp4';
            } else if (transmission.url.endsWith('.m4v')) {
                source.type = 'video/mp4';
            }

            video.appendChild(source);

            // Update UI - combine protocol and code
            transmissionElement.textContent = `${transmission.protocol} ${transmission.code}`;

            console.log(`Display updated: ${transmission.protocol} ${transmission.code}`);

            // Load and play
            video.load();

            // Attempt to play
            const playPromise = video.play();
            if (playPromise !== undefined) {
                playPromise.catch(err => {
                    console.error('Autoplay failed:', err);
                    console.log('User interaction required to start playback');
                });
            }
        }

        // Format time remaining
        function formatTimeRemaining(seconds) {
            const minutes = Math.ceil(seconds / 60);
            return `${minutes}M REMAINING`;
        }

        // Update timer
        function updateTimer() {
            if (video.duration && !isNaN(video.duration)) {
                const remaining = video.duration - video.currentTime;
                timerElement.textContent = formatTimeRemaining(remaining);
            }
        }

        // Video ended - advance to next
        video.addEventListener('ended', () => {
            currentIndex = (currentIndex + 1) % transmissions.length;
            loadTransmission(currentIndex);
        });

        // Update timer every second
        video.addEventListener('timeupdate', updateTimer);

        // Handle metadata loaded
        video.addEventListener('loadedmetadata', updateTimer);

        // Error handling with detailed debugging
        video.addEventListener('error', (e) => {
            console.error('=== VIDEO ERROR ===');
            console.error('Error event:', e);
            console.error('Video error code:', video.error ? video.error.code : 'unknown');
            console.error('Video error message:', video.error ? video.error.message : 'unknown');
            console.error('Current source:', video.currentSrc);
            console.error('Video src attribute:', video.src);
            console.error('Network state:', video.networkState);
            console.error('Ready state:', video.readyState);

            // Also check source element errors
            const sources = video.querySelectorAll('source');
            sources.forEach((source, i) => {
                console.error(`Source ${i} src:`, source.src);
                console.error(`Source ${i} type:`, source.type);
            });
        });

        video.addEventListener('loadstart', () => {
            console.log('✓ Video load started:', video.src || video.currentSrc);
        });

        video.addEventListener('canplay', () => {
            console.log('✓ Video can play - ready to start');
        });

        video.addEventListener('playing', () => {
            console.log('✓ Video is NOW PLAYING');
        });

        video.addEventListener('loadeddata', () => {
            console.log('✓ Video data loaded');
        });

        // Handle user interaction for autoplay (mobile/browser restrictions)
        document.addEventListener('click', () => {
            if (video.paused) {
                console.log('User clicked - attempting to play');
                video.play().catch(err => console.error('Play failed after click:', err));
            }
        }, { once: true });

        // Global keyboard shortcut - press 'N' to skip to next transmission
        // Works at any time during playback
        console.log('Setting up keyboard listener for N key');

        window.addEventListener('keydown', (e) => {
            console.log('Key pressed:', e.key, 'Code:', e.code);

            // Check if 'N' key is pressed (case insensitive)
            if (e.key === 'n' || e.key === 'N' || e.code === 'KeyN') {
                e.preventDefault(); // Prevent any default behavior
                e.stopPropagation(); // Stop event from bubbling

                console.log('N key detected! Advancing to next transmission');
                console.log('Current index before:', currentIndex);

                currentIndex = (currentIndex + 1) % transmissions.length;

                console.log('Current index after:', currentIndex);
                loadTransmission(currentIndex);
            }
        }, true); // Use capture phase to ensure it fires first

        console.log('Keyboard listener active');
    </script>
</body>
</html>
